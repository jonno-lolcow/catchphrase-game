<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Reaper Reveal</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #f5f5f5;
    }

    body {
      margin: 0;
      padding: 0.75rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }

    h1 {
      margin: 0;
      margin-bottom: 0.25rem;
      font-size: 1.9rem;
      text-align: center;
    }

    .container {
      display: flex;
      flex-wrap: nowrap;
      gap: 1rem;
      width: 100%;
      max-width: 1400px;
      align-items: stretch;
    }

    .panel {
      background: #1f1f1f;
      border-radius: 8px;
      padding: 0.75rem 1rem;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.35);
    }

    .panel h2 {
      margin-top: 0;
      font-size: 1.05rem;
      border-bottom: 1px solid #333;
      padding-bottom: 0.25rem;
      margin-bottom: 0.5rem;
    }

    .side-column {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      flex: 1.3 1 320px;
      max-width: 420px;
    }

    label {
      display: block;
      font-size: 0.8rem;
      margin-top: 0.4rem;
      margin-bottom: 0.15rem;
      color: #ccc;
    }

    input[type="text"],
    input[type="number"] {
      width: 100%;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      border: 1px solid #444;
      background: #111;
      color: #f5f5f5;
      box-sizing: border-box;
      font-size: 0.9rem;
    }

    input[type="number"] {
      -moz-appearance: textfield;
    }
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    button {
      margin-top: 0.35rem;
      margin-right: 0.4rem;
      padding: 0.4rem 0.7rem;
      border-radius: 4px;
      border: 1px solid #555;
      background: #2a2a2a;
      color: #f5f5f5;
      font-size: 0.9rem;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    button.primary {
      background: #1464ff;
      border-color: #2c7cff;
    }

    button.danger {
      background: #aa1a1a;
      border-color: #ff5555;
    }

    .row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 0.3rem;
    }

    .small {
      font-size: 0.8rem;
      color: #bbb;
    }

    .status {
      margin-top: 0.4rem;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      background: #111;
      border: 1px solid #333;
      font-size: 0.85rem;
      min-height: 1.6em;
    }

    .status.ok {
      border-color: #2f8f2f;
      color: #b2f5b2;
    }

    .status.error {
      border-color: #b52b2b;
      color: #ffb2b2;
    }

    /* Board */
    .board-wrapper {
      flex: 3 1 720px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    #boardContainer {
      position: relative;
      width: 100%;
      margin: 0 auto;
      border-radius: 10px;
      overflow: hidden;
      background: #000;
      aspect-ratio: 16 / 9;
      box-shadow: 0 0 14px rgba(0, 0, 0, 0.7);
    }

    #imageLayer,
    #tilesLayer {
      position: absolute;
      inset: 0;
    }

    #imageLayer {
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: brightness(0.9);
    }

    #tilesLayer {
      display: grid;
    }

    .tile {
      background: #333;
      border: 1px solid #111;
      transition: background 0.25s ease;
    }

    .tile.revealed {
      background: transparent;
      border-color: transparent;
    }

    #overlayMessage {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      font-size: 1.4rem;
      text-shadow: 0 0 5px #000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      text-align: center;
      padding: 1rem;
      white-space: pre-line;
    }

    #overlayMessage.visible {
      opacity: 1;
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
      font-size: 0.9rem;
    }

    .score-badge {
      padding: 0.6rem 1.1rem;
      border-radius: 999px;
      background: #111;
      border: 1px solid #444;
      min-width: 150px;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-sizing: border-box;
    }

    .current-turn {
      border-color: #f5c14a;
      box-shadow: 0 0 8px rgba(245, 193, 74, 0.6);
    }

    .score-badge span {
      display: block;
    }

    .score-name {
      font-weight: 600;
    }

    .score-value {
      font-size: 1.15rem;
      margin-top: 0.1rem;
    }

    .tag {
      display: inline-block;
      font-size: 0.75rem;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      border: 1px solid #555;
      background: #111;
      margin-left: 0.4rem;
    }

    /* Collapsible setup */
    .collapsible-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      user-select: none;
      padding-bottom: 0.25rem;
      border-bottom: 1px solid #333;
      margin-bottom: 0.5rem;
    }

    .collapsible-header h2 {
      border: none;
      margin: 0;
      padding: 0;
      font-size: 1.05rem;
    }

    .collapsible-icon {
      font-size: 0.9rem;
      color: #ccc;
    }

    .collapsible-content.collapsed {
      display: none;
    }

    @media (max-width: 900px) {
      .container {
        flex-wrap: wrap;
      }
      .board-wrapper {
        order: -1;
        flex: 1 1 100%;
      }
      .side-column {
        flex: 1 1 100%;
        max-width: 100%;
      }
    }
  </style>
</head>
<body>
  <h1>Reaper Reveal</h1>

  <div class="container">
    <!-- Board on the left -->
    <div class="board-wrapper">
      <div id="boardContainer">
        <div id="imageLayer"></div>
        <div id="tilesLayer"></div>
        <div id="overlayMessage"></div>
      </div>
    </div>

    <!-- Right column: players/guess + collapsible setup -->
    <div class="side-column">
      <!-- Players & Guess -->
      <div class="panel">
        <h2>Players & Turns</h2>

        <div class="score-row" style="margin-top:0.4rem;">
          <div class="score-badge" id="score1Badge">
            <span class="score-name" id="score1Name">Xylie</span>
            <span class="score-value"><span id="score1">0</span> pts</span>
          </div>
          <div class="score-badge" id="score2Badge">
            <span class="score-name" id="score2Name">Josh</span>
            <span class="score-value"><span id="score2">0</span> pts</span>
          </div>
        </div>

        <div class="row" style="margin-top:0.6rem;">
          <span>Current turn: <strong id="currentTurnLabel">Xylie</strong></span>
          <span class="tag">Changes after each guess / skip</span>
        </div>

        <h2 style="margin-top:0.9rem;">Guess</h2>

        <label for="guessInput">Enter guess</label>
        <input type="text" id="guessInput" placeholder="Enter catchphrase guess here..." />

        <div class="row">
          <button id="submitGuessBtn" class="primary">Submit Guess</button>
          <button id="skipGuessBtn">Skip Turn</button>
        </div>

        <div class="row" style="margin-top:0.6rem;">
          <button id="revealTileBtn" class="primary">Reveal Random Tile</button>
        </div>

        <div class="status" id="guessStatus"></div>
      </div>

      <!-- Collapsible Setup -->
      <div class="panel" id="setupPanel">
        <div class="collapsible-header" id="setupToggle">
          <h2>Setup</h2>
          <span class="collapsible-icon" id="setupToggleIcon">▲</span>
        </div>

        <div id="setupContent" class="collapsible-content">
          <p class="small" id="puzzleLoadInfo">Loading puzzles…</p>

          <div class="row">
            <div style="flex:1">
              <label for="rowsInput">Rows</label>
              <input type="number" id="rowsInput" min="1" max="20" value="4" />
            </div>
            <div style="flex:1">
              <label for="colsInput">Columns</label>
              <input type="number" id="colsInput" min="1" max="20" value="6" />
            </div>
          </div>

          <div class="row">
            <button id="startRoundBtn" class="primary">Start / Reset Round</button>
            <button id="revealAllBtn" class="danger" disabled>Reveal All / Give Up</button>
          </div>

          <div class="row">
            <button id="resetScoresBtn">Reset Scores</button>
          </div>

          <div class="status" id="setupStatus"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ----- State -----
    let puzzles = [];
    let currentPuzzle = null;
    let currentPuzzleAnswersNormalized = [];
    let tiles = [];
    let unrevealedTileIndices = [];
    let totalTiles = 0;
    let revealedTilesCount = 0;
    let gameActive = false;
    let currentPlayerIndex = 0; // 0 = Xylie, 1 = Josh
    let scores = [0, 0];
    let hasStartedAtLeastOnce = false;

    // ----- DOM Elements -----
    const rowsInput = document.getElementById("rowsInput");
    const colsInput = document.getElementById("colsInput");

    const startRoundBtn = document.getElementById("startRoundBtn");
    const revealAllBtn = document.getElementById("revealAllBtn");
    const resetScoresBtn = document.getElementById("resetScoresBtn");

    const setupStatus = document.getElementById("setupStatus");
    const guessStatus = document.getElementById("guessStatus");
    const puzzleLoadInfo = document.getElementById("puzzleLoadInfo");

    const score1El = document.getElementById("score1");
    const score2El = document.getElementById("score2");
    const score1Badge = document.getElementById("score1Badge");
    const score2Badge = document.getElementById("score2Badge");
    const score1NameEl = document.getElementById("score1Name");
    const score2NameEl = document.getElementById("score2Name");
    const currentTurnLabel = document.getElementById("currentTurnLabel");

    const guessInput = document.getElementById("guessInput");
    const submitGuessBtn = document.getElementById("submitGuessBtn");
    const skipGuessBtn = document.getElementById("skipGuessBtn");
    const revealTileBtn = document.getElementById("revealTileBtn");

    const boardContainer = document.getElementById("boardContainer");
    const imageLayer = document.getElementById("imageLayer");
    const tilesLayer = document.getElementById("tilesLayer");
    const overlayMessage = document.getElementById("overlayMessage");

    // Collapsible setup
    const setupToggle = document.getElementById("setupToggle");
    const setupToggleIcon = document.getElementById("setupToggleIcon");
    const setupContent = document.getElementById("setupContent");

    // ----- Helpers -----
    function setSetupStatus(message, type = "") {
      setupStatus.textContent = message || "";
      setupStatus.classList.remove("ok", "error");
      if (type) setupStatus.classList.add(type);
    }

    function setGuessStatus(message, type = "") {
      guessStatus.textContent = message || "";
      guessStatus.classList.remove("ok", "error");
      if (type) guessStatus.classList.add(type);
    }

    function normalizeAnswer(str) {
      return (str || "")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function updatePlayerNames() {
      score1NameEl.textContent = "Xylie";
      score2NameEl.textContent = "Josh";
      currentTurnLabel.textContent =
        currentPlayerIndex === 0 ? "Xylie" : "Josh";
    }

    function updateScores() {
      score1El.textContent = scores[0];
      score2El.textContent = scores[1];
    }

    function highlightCurrentTurn() {
      score1Badge.classList.toggle("current-turn", currentPlayerIndex === 0);
      score2Badge.classList.toggle("current-turn", currentPlayerIndex === 1);
      updatePlayerNames();
    }

    function switchTurn() {
      currentPlayerIndex = currentPlayerIndex === 0 ? 1 : 0;
      highlightCurrentTurn();
    }

    function showOverlayMessage(text) {
      overlayMessage.textContent = text;
      overlayMessage.classList.add("visible");
    }

    function hideOverlayMessage() {
      overlayMessage.textContent = "";
      overlayMessage.classList.remove("visible");
    }

    function disableGameControls(disabled) {
      revealTileBtn.disabled = disabled;
      revealAllBtn.disabled = disabled;
      submitGuessBtn.disabled = disabled;
      skipGuessBtn.disabled = disabled;
      guessInput.disabled = disabled;
    }

    // Collapsible behaviour
    function setSetupCollapsed(collapsed) {
      if (collapsed) {
        setupContent.classList.add("collapsed");
        setupToggleIcon.textContent = "▼";
      } else {
        setupContent.classList.remove("collapsed");
        setupToggleIcon.textContent = "▲";
      }
    }

    setupToggle.addEventListener("click", () => {
      const collapsed = setupContent.classList.contains("collapsed");
      setSetupCollapsed(!collapsed);
    });

    // ----- Load puzzles.json -----
    async function loadPuzzles() {
      try {
        const res = await fetch("data/puzzles.json", {
          cache: "no-store"
        });
        if (!res.ok) {
          throw new Error("HTTP " + res.status);
        }
        const data = await res.json();
        if (!Array.isArray(data) || data.length === 0) {
          puzzleLoadInfo.textContent = "No puzzles found in data/puzzles.json.";
          setSetupStatus("No puzzles loaded. Check data/puzzles.json.", "error");
          return;
        }
        puzzles = data;
        puzzleLoadInfo.textContent = `Puzzles loaded: ${puzzles.length}. Ready to play.`;
        setSetupStatus("Puzzles loaded. Set rows/columns and click Start / Reset Round.", "ok");
      } catch (err) {
        console.error("Error loading puzzles:", err);
        puzzleLoadInfo.textContent = "Failed to load puzzles.";
        setSetupStatus("Failed to load data/puzzles.json. Make sure it exists on the server.", "error");
      }
    }

    // ----- Round Setup -----
    function pickRandomPuzzle() {
      if (!puzzles || puzzles.length === 0) return null;
      const randomIndex = Math.floor(Math.random() * puzzles.length);
      return puzzles[randomIndex];
    }

    function setupRound() {
      setGuessStatus("");
      hideOverlayMessage();

      if (!puzzles || puzzles.length === 0) {
        setSetupStatus("No puzzles loaded yet. Check data/puzzles.json.", "error");
        return;
      }

      const rows = parseInt(rowsInput.value, 10) || 0;
      const cols = parseInt(colsInput.value, 10) || 0;

      if (rows <= 0 || cols <= 0) {
        setSetupStatus("Rows and columns must be at least 1.", "error");
        return;
      }

      const puzzle = pickRandomPuzzle();
      if (!puzzle || !puzzle.image || !Array.isArray(puzzle.answers) || puzzle.answers.length === 0) {
        setSetupStatus("Random puzzle is invalid. Check data/puzzles.json.", "error");
        return;
      }

      currentPuzzle = puzzle;
      currentPuzzleAnswersNormalized = puzzle.answers.map(normalizeAnswer);

      imageLayer.style.backgroundImage = `url('${puzzle.image}')`;

      tilesLayer.innerHTML = "";
      tiles = [];
      unrevealedTileIndices = [];
      totalTiles = rows * cols;
      revealedTilesCount = 0;

      tilesLayer.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
      tilesLayer.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

      for (let i = 0; i < totalTiles; i++) {
        const div = document.createElement("div");
        div.classList.add("tile");
        tilesLayer.appendChild(div);
        tiles.push(div);
        unrevealedTileIndices.push(i);
      }

      gameActive = true;
      disableGameControls(false);
      revealAllBtn.disabled = false;
      guessInput.value = "";
      setSetupStatus(`Round started with ${rows} × ${cols} grid (${totalTiles} tiles).`, "ok");
      setGuessStatus("Reveal a tile and let the current player guess or skip.", "ok");
      hideOverlayMessage();

      if (!hasStartedAtLeastOnce) {
        hasStartedAtLeastOnce = true;
        setTimeout(() => setSetupCollapsed(true), 200);
      }
    }

    startRoundBtn.addEventListener("click", () => {
      setupRound();
    });

    // ----- Reveal Tiles -----
    function revealRandomTile() {
      if (!gameActive) {
        setGuessStatus("Start a round first.", "error");
        return;
      }
      if (unrevealedTileIndices.length === 0) {
        setGuessStatus("All tiles are already revealed.", "error");
        return;
      }

      const randomIndex = Math.floor(Math.random() * unrevealedTileIndices.length);
      const tileIndex = unrevealedTileIndices[randomIndex];
      unrevealedTileIndices.splice(randomIndex, 1);

      const tile = tiles[tileIndex];
      if (tile && !tile.classList.contains("revealed")) {
        tile.classList.add("revealed");
        revealedTilesCount++;
      }

      setGuessStatus("Tile revealed. Current player may guess or skip.", "");
    }

    revealTileBtn.addEventListener("click", () => {
      revealRandomTile();
    });

    // ----- Reveal All -----
    function revealAllTiles() {
      tiles.forEach((tile) => tile.classList.add("revealed"));
      unrevealedTileIndices = [];
      revealedTilesCount = totalTiles;
    }

    revealAllBtn.addEventListener("click", () => {
      if (!currentPuzzle) {
        revealAllTiles();
        return;
      }
      if (!gameActive) {
        revealAllTiles();
        return;
      }
      revealAllTiles();
      gameActive = false;
      disableGameControls(true);
      showOverlayMessage("Round over – no correct guess!");
      setGuessStatus("Round ended. Click Start / Reset Round for a new puzzle.", "error");
    });

    // ----- Guess Handling -----
    function handleGuess() {
      if (!gameActive) {
        setGuessStatus("Start a round first.", "error");
        return;
      }
      if (!currentPuzzle) {
        setGuessStatus("No puzzle selected. Start a round.", "error");
        return;
      }

      const guess = guessInput.value.trim();
      if (!guess) {
        setGuessStatus("Enter a guess first or use Skip Turn.", "error");
        return;
      }

      const normalizedGuess = normalizeAnswer(guess);
      const isCorrect = currentPuzzleAnswersNormalized.some((ans) => ans === normalizedGuess);

      if (isCorrect) {
        const tilesRemaining = totalTiles - revealedTilesCount;
        const pointsAwarded = tilesRemaining + 1;
        scores[currentPlayerIndex] += pointsAwarded;
        updateScores();

        const playerName = currentPlayerIndex === 0 ? "Xylie" : "Josh";

        setGuessStatus(
          `${playerName} is correct! +${pointsAwarded} points (tiles remaining: ${tilesRemaining}).`,
          "ok"
        );
        revealAllTiles();
        gameActive = false;
        disableGameControls(true);
        showOverlayMessage(`${playerName} got it!\n+${pointsAwarded} points`);
      } else {
        setGuessStatus("Incorrect guess. Turn passes to the other player.", "error");
        guessInput.value = "";
        switchTurn();
      }
    }

    submitGuessBtn.addEventListener("click", handleGuess);

    guessInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        handleGuess();
      }
    });

    skipGuessBtn.addEventListener("click", () => {
      if (!gameActive) {
        setGuessStatus("Start a round first.", "error");
        return;
      }
      setGuessStatus("Turn skipped. Passing to the other player.", "");
      guessInput.value = "";
      switchTurn();
    });

    // ----- Scores reset -----
    resetScoresBtn.addEventListener("click", () => {
      scores = [0, 0];
      updateScores();
      setSetupStatus("Scores reset.", "ok");
    });

    // ----- Init -----
    updateScores();
    highlightCurrentTurn();
    disableGameControls(true);
    setSetupCollapsed(false); // visible at start
    setSetupStatus("Loading puzzles…", "");
    loadPuzzles();
  </script>
</body>
</html>
