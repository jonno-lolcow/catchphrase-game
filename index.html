<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Catchphrase-Style Reveal Game</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #f5f5f5;
    }

    body {
      margin: 0;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
    }

    h1 {
      margin: 0;
      font-size: 1.5rem;
      text-align: center;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      width: 100%;
      max-width: 1100px;
    }

    .panel {
      background: #1f1f1f;
      border-radius: 8px;
      padding: 0.75rem 1rem;
      flex: 1 1 260px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.35);
    }

    .panel h2 {
      margin-top: 0;
      font-size: 1.1rem;
      border-bottom: 1px solid #333;
      padding-bottom: 0.25rem;
      margin-bottom: 0.5rem;
    }

    label {
      display: block;
      font-size: 0.8rem;
      margin-top: 0.5rem;
      margin-bottom: 0.15rem;
      color: #ccc;
    }

    input[type="text"],
    input[type="number"] {
      width: 100%;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      border: 1px solid #444;
      background: #111;
      color: #f5f5f5;
      box-sizing: border-box;
      font-size: 0.9rem;
    }

    input[type="number"] {
      -moz-appearance: textfield;
    }
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    button {
      margin-top: 0.4rem;
      margin-right: 0.4rem;
      padding: 0.4rem 0.7rem;
      border-radius: 4px;
      border: 1px solid #555;
      background: #2a2a2a;
      color: #f5f5f5;
      font-size: 0.9rem;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    button.primary {
      background: #1464ff;
      border-color: #2c7cff;
    }

    button.danger {
      background: #aa1a1a;
      border-color: #ff5555;
    }

    .row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 0.3rem;
    }

    .small {
      font-size: 0.8rem;
      color: #bbb;
    }

    .status {
      margin-top: 0.5rem;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      background: #111;
      border: 1px solid #333;
      font-size: 0.85rem;
      min-height: 1.6em;
    }

    .status.ok {
      border-color: #2f8f2f;
      color: #b2f5b2;
    }

    .status.error {
      border-color: #b52b2b;
      color: #ffb2b2;
    }

    /* Board */
    .board-wrapper {
      flex: 2 1 480px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    #boardContainer {
      position: relative;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      border-radius: 8px;
      overflow: hidden;
      background: #000;
      aspect-ratio: 16 / 9;
      box-shadow: 0 0 12px rgba(0, 0, 0, 0.6);
    }

    #imageLayer,
    #tilesLayer {
      position: absolute;
      inset: 0;
    }

    #imageLayer {
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: brightness(0.9);
    }

    #tilesLayer {
      display: grid;
    }

    .tile {
      background: #333;
      border: 1px solid #111;
      transition: background 0.25s ease;
    }

    .tile.revealed {
      background: transparent;
      border-color: transparent;
    }

    #overlayMessage {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      font-size: 1.4rem;
      text-shadow: 0 0 5px #000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      text-align: center;
      padding: 1rem;
      white-space: pre-line;
    }

    #overlayMessage.visible {
      opacity: 1;
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
      font-size: 0.9rem;
    }

    .score-badge {
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      background: #111;
      border: 1px solid #444;
      min-width: 120px;
    }

    .current-turn {
      border-color: #f5c14a;
      box-shadow: 0 0 8px rgba(245, 193, 74, 0.35);
    }

    .score-badge span {
      display: block;
    }

    .score-name {
      font-weight: 600;
    }

    .score-value {
      font-size: 1.1rem;
      margin-top: 0.1rem;
    }

    .tag {
      display: inline-block;
      font-size: 0.75rem;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      border: 1px solid #555;
      background: #111;
      margin-left: 0.4rem;
    }

    @media (max-width: 800px) {
      .container {
        flex-direction: column;
      }
      .board-wrapper {
        order: -1;
      }
    }
  </style>
</head>
<body>
  <h1>Catchphrase-Style Reveal Game</h1>

  <div class="container">
    <!-- Left: Game controls -->
    <div class="panel">
      <h2>Setup</h2>

      <p class="small" id="puzzleLoadInfo">Loading puzzles…</p>

      <div class="row">
        <div style="flex:1">
          <label for="rowsInput">Rows</label>
          <input type="number" id="rowsInput" min="1" max="20" value="4" />
        </div>
        <div style="flex:1">
          <label for="colsInput">Columns</label>
          <input type="number" id="colsInput" min="1" max="20" value="6" />
        </div>
      </div>

      <div class="row">
        <button id="startRoundBtn" class="primary">Start / Reset Round</button>
        <button id="revealAllBtn" class="danger" disabled>Reveal All / Give Up</button>
      </div>

      <div class="row">
        <button id="resetScoresBtn">Reset Scores</button>
      </div>

      <div class="status" id="setupStatus"></div>
    </div>

    <!-- Right: Scores / Guessing -->
    <div class="panel">
      <h2>Players & Scoring</h2>

      <label for="player1Input">Player 1 name</label>
      <input type="text" id="player1Input" value="Player 1" />

      <label for="player2Input">Player 2 name</label>
      <input type="text" id="player2Input" value="Player 2" />

      <div class="score-row" style="margin-top:0.6rem;">
        <div class="score-badge" id="score1Badge">
          <span class="score-name" id="score1Name">Player 1</span>
          <span class="score-value"><span id="score1">0</span> pts</span>
        </div>
        <div class="score-badge" id="score2Badge">
          <span class="score-name" id="score2Name">Player 2</span>
          <span class="score-value"><span id="score2">0</span> pts</span>
        </div>
      </div>

      <p class="small">
        <strong>Scoring:</strong> Points for a correct guess = tiles remaining + 1.
        Earlier guesses = more points.
      </p>

      <div class="row" style="margin-top:0.8rem;">
        <span>Current turn: <strong id="currentTurnLabel">Player 1</strong></span>
        <span class="tag">Changes after each guess</span>
      </div>

      <h2 style="margin-top:1rem;">Guess</h2>

      <label for="guessInput">Enter guess</label>
      <input type="text" id="guessInput" placeholder="Enter catchphrase guess here..." />

      <div class="row">
        <button id="submitGuessBtn">Submit Guess</button>
        <button id="revealTileBtn" class="primary">Reveal Random Tile</button>
      </div>

      <div class="status" id="guessStatus"></div>
    </div>

    <!-- Board -->
    <div class="board-wrapper">
      <h2>Board</h2>
      <div id="boardContainer">
        <div id="imageLayer"></div>
        <div id="tilesLayer"></div>
        <div id="overlayMessage"></div>
      </div>
      <p class="small">
        Host flow per turn: <strong>Reveal Random Tile → Player makes a guess → Submit Guess.</strong><br />
        Puzzles and answers are pre-defined; hosts won’t see the correct answer unless they inspect the files.
      </p>
    </div>
  </div>

  <script>
    // ----- State -----
    let puzzles = [];
    let currentPuzzle = null;
    let currentPuzzleAnswersNormalized = [];
    let tiles = [];
    let unrevealedTileIndices = [];
    let totalTiles = 0;
    let revealedTilesCount = 0;
    let gameActive = false;
    let currentPlayerIndex = 0; // 0 = player 1, 1 = player 2
    let scores = [0, 0];

    // ----- DOM Elements -----
    const rowsInput = document.getElementById("rowsInput");
    const colsInput = document.getElementById("colsInput");

    const startRoundBtn = document.getElementById("startRoundBtn");
    const revealAllBtn = document.getElementById("revealAllBtn");
    const resetScoresBtn = document.getElementById("resetScoresBtn");

    const setupStatus = document.getElementById("setupStatus");
    const guessStatus = document.getElementById("guessStatus");
    const puzzleLoadInfo = document.getElementById("puzzleLoadInfo");

    const player1Input = document.getElementById("player1Input");
    const player2Input = document.getElementById("player2Input");
    const score1El = document.getElementById("score1");
    const score2El = document.getElementById("score2");
    const score1Badge = document.getElementById("score1Badge");
    const score2Badge = document.getElementById("score2Badge");
    const score1NameEl = document.getElementById("score1Name");
    const score2NameEl = document.getElementById("score2Name");
    const currentTurnLabel = document.getElementById("currentTurnLabel");

    const guessInput = document.getElementById("guessInput");
    const submitGuessBtn = document.getElementById("submitGuessBtn");
    const revealTileBtn = document.getElementById("revealTileBtn");

    const boardContainer = document.getElementById("boardContainer");
    const imageLayer = document.getElementById("imageLayer");
    const tilesLayer = document.getElementById("tilesLayer");
    const overlayMessage = document.getElementById("overlayMessage");

    // ----- Helpers -----
    function setSetupStatus(message, type = "") {
      setupStatus.textContent = message || "";
      setupStatus.classList.remove("ok", "error");
      if (type) setupStatus.classList.add(type);
    }

    function setGuessStatus(message, type = "") {
      guessStatus.textContent = message || "";
      guessStatus.classList.remove("ok", "error");
      if (type) guessStatus.classList.add(type);
    }

    function normalizeAnswer(str) {
      return (str || "")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function updatePlayerNames() {
      const p1 = player1Input.value.trim() || "Player 1";
      const p2 = player2Input.value.trim() || "Player 2";
      score1NameEl.textContent = p1;
      score2NameEl.textContent = p2;
      currentTurnLabel.textContent =
        currentPlayerIndex === 0 ? p1 : p2;
    }

    function updateScores() {
      score1El.textContent = scores[0];
      score2El.textContent = scores[1];
    }

    function highlightCurrentTurn() {
      score1Badge.classList.toggle("current-turn", currentPlayerIndex === 0);
      score2Badge.classList.toggle("current-turn", currentPlayerIndex === 1);
      updatePlayerNames();
    }

    function switchTurn() {
      currentPlayerIndex = currentPlayerIndex === 0 ? 1 : 0;
      highlightCurrentTurn();
    }

    function showOverlayMessage(text) {
      overlayMessage.textContent = text;
      overlayMessage.classList.add("visible");
    }

    function hideOverlayMessage() {
      overlayMessage.textContent = "";
      overlayMessage.classList.remove("visible");
    }

    function disableGameControls(disabled) {
      submitGuessBtn.disabled = disabled;
      revealTileBtn.disabled = disabled;
      revealAllBtn.disabled = disabled;
    }

    // ----- Load puzzles.json -----
    async function loadPuzzles() {
      try {
        const res = await fetch("data/puzzles.json", {
          cache: "no-store"
        });
        if (!res.ok) {
          throw new Error("HTTP " + res.status);
        }
        const data = await res.json();
        if (!Array.isArray(data) || data.length === 0) {
          puzzleLoadInfo.textContent = "No puzzles found in data/puzzles.json.";
          setSetupStatus("No puzzles loaded. Check data/puzzles.json.", "error");
          return;
        }
        puzzles = data;
        puzzleLoadInfo.textContent = `Puzzles loaded: ${puzzles.length}. Ready to play.`;
        setSetupStatus("Puzzles loaded. Set rows/columns and click Start / Reset Round.", "ok");
      } catch (err) {
        console.error("Error loading puzzles:", err);
        puzzleLoadInfo.textContent = "Failed to load puzzles.";
        setSetupStatus("Failed to load data/puzzles.json. Make sure it exists on the server.", "error");
      }
    }

    // ----- Round Setup -----
    function pickRandomPuzzle() {
      if (!puzzles || puzzles.length === 0) return null;
      const randomIndex = Math.floor(Math.random() * puzzles.length);
      return puzzles[randomIndex];
    }

    function setupRound() {
      setGuessStatus("");
      hideOverlayMessage();

      if (!puzzles || puzzles.length === 0) {
        setSetupStatus("No puzzles loaded yet. Check data/puzzles.json.", "error");
        return;
      }

      const rows = parseInt(rowsInput.value, 10) || 0;
      const cols = parseInt(colsInput.value, 10) || 0;

      if (rows <= 0 || cols <= 0) {
        setSetupStatus("Rows and columns must be at least 1.", "error");
        return;
      }

      // Choose puzzle at random
      const puzzle = pickRandomPuzzle();
      if (!puzzle || !puzzle.image || !Array.isArray(puzzle.answers) || puzzle.answers.length === 0) {
        setSetupStatus("Random puzzle is invalid. Check data/puzzles.json.", "error");
        return;
      }

      currentPuzzle = puzzle;
      currentPuzzleAnswersNormalized = puzzle.answers.map(normalizeAnswer);

      // Apply image
      imageLayer.style.backgroundImage = `url('${puzzle.image}')`;

      // Build tiles
      tilesLayer.innerHTML = "";
      tiles = [];
      unrevealedTileIndices = [];
      totalTiles = rows * cols;
      revealedTilesCount = 0;

      tilesLayer.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
      tilesLayer.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

      for (let i = 0; i < totalTiles; i++) {
        const div = document.createElement("div");
        div.classList.add("tile");
        tilesLayer.appendChild(div);
        tiles.push(div);
        unrevealedTileIndices.push(i);
      }

      gameActive = true;
      disableGameControls(false);
      revealAllBtn.disabled = false;
      setSetupStatus(`Round started with ${rows} × ${cols} grid (${totalTiles} tiles).`, "ok");
      setGuessStatus("Reveal a tile, then make a guess.", "ok");
      hideOverlayMessage();
    }

    startRoundBtn.addEventListener("click", () => {
      setupRound();
    });

    // ----- Reveal Tiles -----
    function revealRandomTile() {
      if (!gameActive) {
        setGuessStatus("Start a round first.", "error");
        return;
      }
      if (unrevealedTileIndices.length === 0) {
        setGuessStatus("All tiles are already revealed.", "error");
        return;
      }

      const randomIndex = Math.floor(Math.random() * unrevealedTileIndices.length);
      const tileIndex = unrevealedTileIndices[randomIndex];
      unrevealedTileIndices.splice(randomIndex, 1);

      const tile = tiles[tileIndex];
      if (tile && !tile.classList.contains("revealed")) {
        tile.classList.add("revealed");
        revealedTilesCount++;
      }

      setGuessStatus("Tile revealed. Enter your guess.", "");
    }

    revealTileBtn.addEventListener("click", () => {
      revealRandomTile();
    });

    // ----- Reveal All -----
    function revealAllTiles() {
      tiles.forEach((tile) => tile.classList.add("revealed"));
      unrevealedTileIndices = [];
      revealedTilesCount = totalTiles;
    }

    revealAllBtn.addEventListener("click", () => {
      if (!currentPuzzle) {
        // Still allow it to show empty board state
        revealAllTiles();
        return;
      }
      if (!gameActive) {
        revealAllTiles();
        return;
      }
      revealAllTiles();
      gameActive = false;
      disableGameControls(true);
      showOverlayMessage("Round over – no correct guess!");
      setGuessStatus("Round ended. Click Start / Reset Round for a new puzzle.", "error");
    });

    // ----- Guess Handling -----
    function handleGuess() {
      if (!gameActive) {
        setGuessStatus("Start a round first.", "error");
        return;
      }
      if (!currentPuzzle) {
        setGuessStatus("No puzzle selected. Start a round.", "error");
        return;
      }

      const guess = guessInput.value.trim();
      if (!guess) {
        setGuessStatus("Enter a guess first.", "error");
        return;
      }

      const normalizedGuess = normalizeAnswer(guess);
      const isCorrect = currentPuzzleAnswersNormalized.some((ans) => ans === normalizedGuess);

      if (isCorrect) {
        const tilesRemaining = totalTiles - revealedTilesCount;
        const pointsAwarded = tilesRemaining + 1; // simple formula
        scores[currentPlayerIndex] += pointsAwarded;
        updateScores();

        const playerName =
          currentPlayerIndex === 0
            ? (player1Input.value.trim() || "Player 1")
            : (player2Input.value.trim() || "Player 2");

        setGuessStatus(
          `${playerName} is correct! +${pointsAwarded} points (tiles remaining: ${tilesRemaining}).`,
          "ok"
        );
        revealAllTiles();
        gameActive = false;
        disableGameControls(true);
        showOverlayMessage(`${playerName} got it!\n+${pointsAwarded} points`);
      } else {
        setGuessStatus("Incorrect guess. Turn passes to the other player.", "error");
        guessInput.value = "";
        switchTurn();
      }
    }

    submitGuessBtn.addEventListener("click", () => {
      handleGuess();
    });

    guessInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        handleGuess();
      }
    });

    // ----- Scores reset -----
    resetScoresBtn.addEventListener("click", () => {
      scores = [0, 0];
      updateScores();
      setSetupStatus("Scores reset.", "ok");
    });

    // ----- Player name changes -----
    player1Input.addEventListener("input", updatePlayerNames);
    player2Input.addEventListener("input", updatePlayerNames);

    // ----- Init -----
    updateScores();
    highlightCurrentTurn();
    disableGameControls(true);
    setSetupStatus("Loading puzzles…", "");
    loadPuzzles();
  </script>
</body>
</html>
