<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Reaper Reveal</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #f5f5f5;
    }

    body {
      margin: 0;
      padding: 0.5rem 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }

    h1 {
      margin: 0;
      margin-bottom: 0.25rem;
      font-size: 1.9rem;
      text-align: center;
    }

    .container {
      display: flex;
      flex-wrap: nowrap;
      gap: 0.75rem;
      width: 96vw;
      max-width: 96vw;
      align-items: flex-start;
    }

    .panel {
      background: #1f1f1f;
      border-radius: 8px;
      padding: 0.75rem 1rem;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.35);
    }

    .panel h2 {
      margin-top: 0;
      font-size: 1.05rem;
      border-bottom: 1px solid #333;
      padding-bottom: 0.25rem;
      margin-bottom: 0.5rem;
    }

    .side-column {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      flex: 1.5 0 320px;
      max-width: 420px;
    }

    label {
      display: block;
      font-size: 0.8rem;
      margin-top: 0.4rem;
      margin-bottom: 0.15rem;
      color: #ccc;
    }

    input[type="text"],
    input[type="number"] {
      width: 100%;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      border: 1px solid #444;
      background: #111;
      color: #f5f5f5;
      box-sizing: border-box;
      font-size: 0.9rem;
    }

    input[type="number"] {
      -moz-appearance: textfield;
    }
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    button {
      margin-top: 0.35rem;
      margin-right: 0.4rem;
      padding: 0.4rem 0.7rem;
      border-radius: 4px;
      border: 1px solid #555;
      background: #2a2a2a;
      color: #f5f5f5;
      font-size: 0.9rem;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    button.primary {
      background: #1464ff;
      border-color: #2c7cff;
    }

    button.danger {
      background: #aa1a1a;
      border-color: #ff5555;
    }

    .row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 0.3rem;
    }

    .small {
      font-size: 0.8rem;
      color: #bbb;
    }

    .status {
      margin-top: 0.4rem;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      background: #111;
      border: 1px solid #333;
      font-size: 0.85rem;
      min-height: 1.6em;
    }

    .status.ok {
      border-color: #2f8f2f;
      color: #b2f5b2;
    }

    .status.error {
      border-color: #b52b2b;
      color: #ffb2b2;
    }

    /* Board */
    .board-wrapper {
      flex: 4 1 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    #boardContainer {
      position: relative;
      width: 100%;
      margin: 0 auto;
      border-radius: 10px;
      overflow: hidden;
      background: #000;
      aspect-ratio: 16 / 9;
      box-shadow: 0 0 14px rgba(0, 0, 0, 0.7);
    }

    #imageLayer,
    #tilesLayer {
      position: absolute;
      inset: 0;
    }

    #imageLayer {
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: brightness(0.9);
    }

    #tilesLayer {
      display: grid;
    }

    .tile {
      background: #333;
      border: 1px solid #111;
      transition: background 1s ease, border-color 1s ease, box-shadow 0.15s ease;
    }

    .tile.revealed {
      background: transparent;
      border-color: transparent;
    }

    .tile.highlight {
      background: #505050;
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.45);
    }

    #overlayMessage {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      font-size: 1.4rem;
      text-shadow: 0 0 5px #000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      text-align: center;
      padding: 1rem;
      white-space: pre-line;
    }

    #overlayMessage.visible {
      opacity: 1;
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: center;
      flex-wrap: wrap;
      font-size: 0.9rem;
    }

    .score-badge {
      padding: 0.6rem 1.1rem;
      border-radius: 999px;
      background: #111;
      border: 1px solid #444;
      min-width: 150px;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-sizing: border-box;
    }

    .current-turn {
      border-color: #f5c14a;
      box-shadow: 0 0 8px rgba(245, 193, 74, 0.6);
    }

    .score-badge span {
      display: block;
    }

    .score-name {
      font-weight: 600;
    }

    .score-value {
      font-size: 1.15rem;
      margin-top: 0.1rem;
    }

    .tag {
      display: inline-block;
      font-size: 0.75rem;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      border: 1px solid #555;
      background: #111;
      margin-left: 0.4rem;
    }

    /* Reaper mascot panel on the right */
    #reaperMascotWrapper {
      margin-top: 0.5rem;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      pointer-events: none;
    }

    #reaperMascotWrapper img {
      max-height: 320px;
      width: auto;
      opacity: 0.95;
      filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.9));
      transition: filter 0.2s ease;
    }

    /* Animations for Reaper */
    @keyframes reaper-wrong {
      0%   { transform: translateX(0); }
      15%  { transform: translateX(-10px); }
      30%  { transform: translateX(10px); }
      45%  { transform: translateX(-8px); }
      60%  { transform: translateX(8px); }
      75%  { transform: translateX(-4px); }
      100% { transform: translateX(0); }
    }

    @keyframes reaper-correct {
      0%   { transform: scale(1) rotate(0deg); }
      20%  { transform: scale(1.07) rotate(-2deg); }
      40%  { transform: scale(1.12) rotate(2deg); }
      60%  { transform: scale(1.08) rotate(-1deg); }
      80%  { transform: scale(1.04) rotate(1deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    #reaperMascotWrapper.wrong img {
      animation: reaper-wrong 0.6s ease;
      filter: drop-shadow(0 0 18px rgba(255, 0, 0, 0.9));
    }

    #reaperMascotWrapper.correct img {
      animation: reaper-correct 0.85s ease-out;
      filter: drop-shadow(0 0 24px rgba(255, 215, 0, 0.95));
    }

    /* Collapsible setup */
    .collapsible-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      user-select: none;
      padding-bottom: 0.25rem;
      border-bottom: 1px solid #333;
      margin-bottom: 0.5rem;
    }

    .collapsible-header h2 {
      border: none;
      margin: 0;
      padding: 0;
      font-size: 1.05rem;
    }

    .collapsible-icon {
      font-size: 0.9rem;
      color: #ccc;
    }

    .collapsible-content.collapsed {
      display: none;
    }

    @media (max-width: 900px) {
      .container {
        flex-wrap: wrap;
      }
      .board-wrapper {
        order: -1;
        flex: 1 1 100%;
      }
      .side-column {
        flex: 1 1 100%;
        max-width: 100%;
      }

      #reaperMascotWrapper img {
        max-height: 220px;
      }
    }
  </style>
</head>
<body>
  <h1>Reaper Reveal</h1>

  <div class="container">
    <!-- Board on the left -->
    <div class="board-wrapper">
      <div id="boardContainer">
        <div id="imageLayer"></div>
        <div id="tilesLayer"></div>
        <div id="overlayMessage"></div>
      </div>
    </div>

    <!-- Right column: players, setup, reaper -->
    <div class="side-column">
      <!-- Players & Guess -->
      <div class="panel">
        <h2>Players & Turns</h2>

        <div class="score-row" style="margin-top:0.4rem;">
          <div class="score-badge" id="score1Badge">
            <span class="score-name" id="score1Name">Xylie</span>
            <span class="score-value"><span id="score1">0</span> pts</span>
          </div>
          <div class="score-badge" id="score2Badge">
            <span class="score-name" id="score2Name">Josh</span>
            <span class="score-value"><span id="score2">0</span> pts</span>
          </div>
        </div>

        <div class="row" style="margin-top:0.6rem;">
          <span>Current turn: <strong id="currentTurnLabel">Xylie</strong></span>
          <span class="tag">Changes after each guess / skip</span>
        </div>

        <h2 style="margin-top:0.9rem;">Guess</h2>

        <input type="text" id="guessInput" placeholder="Guess" />

        <div class="row">
          <button id="submitGuessBtn" class="primary">Guess</button>
          <button id="skipGuessBtn">Skip</button>
          <button id="revealTileBtn" class="primary">Reveal</button>
          <button id="nextRoundBtn" disabled>Next</button>
        </div>

        <div class="status" id="guessStatus"></div>
      </div>

      <!-- Collapsible Setup -->
      <div class="panel" id="setupPanel">
        <div class="collapsible-header" id="setupToggle">
          <h2>Setup</h2>
          <span class="collapsible-icon" id="setupToggleIcon">▲</span>
        </div>

        <div id="setupContent" class="collapsible-content">
          <p class="small" id="puzzleLoadInfo">Loading puzzles…</p>

          <div class="row">
            <div style="flex:1">
              <label for="rowsInput">Rows</label>
              <input type="number" id="rowsInput" min="1" max="20" value="9" />
            </div>
            <div style="flex:1">
              <label for="colsInput">Columns</label>
              <input type="number" id="colsInput" min="1" max="20" value="9" />
            </div>
          </div>

          <div class="row">
            <button id="startRoundBtn" class="primary">Start / Reset Round</button>
            <button id="revealAllBtn" class="danger" disabled>Reveal All / Give Up</button>
          </div>

          <div class="row">
            <button id="resetScoresBtn">Reset Scores</button>
          </div>

          <div class="status" id="setupStatus"></div>
        </div>
      </div>

      <!-- Reaper mascot -->
      <div id="reaperMascotWrapper">
        <img src="img/reaper.png" alt="Reaper mascot">
      </div>
    </div>
  </div>

  <script>
    // ----- State -----
    let puzzles = [];
    let currentPuzzle = null;
    let currentPuzzleAnswersNormalized = [];
    let tiles = [];
    let unrevealedTileIndices = [];
    let totalTiles = 0;
    let revealedTilesCount = 0;
    let gameActive = false;
    let currentPlayerIndex = 0; // 0 = Xylie, 1 = Josh
    let scores = [0, 0];
    let revealAnimationRunning = false;
    let canReveal = false; // controls whether Reveal button is allowed
    let usedPuzzleIndices = [];
    let nextStartingPlayerIndex = 0; // who starts next round

    // ----- DOM Elements -----
    const rowsInput = document.getElementById("rowsInput");
    const colsInput = document.getElementById("colsInput");

    const startRoundBtn = document.getElementById("startRoundBtn");
    const revealAllBtn = document.getElementById("revealAllBtn");
    const resetScoresBtn = document.getElementById("resetScoresBtn");

    const setupStatus = document.getElementById("setupStatus");
    const guessStatus = document.getElementById("guessStatus");
    const puzzleLoadInfo = document.getElementById("puzzleLoadInfo");

    const score1El = document.getElementById("score1");
    const score2El = document.getElementById("score2");
    const score1Badge = document.getElementById("score1Badge");
    const score2Badge = document.getElementById("score2Badge");
    const score1NameEl = document.getElementById("score1Name");
    const score2NameEl = document.getElementById("score2Name");
    const currentTurnLabel = document.getElementById("currentTurnLabel");

    const guessInput = document.getElementById("guessInput");
    const submitGuessBtn = document.getElementById("submitGuessBtn");
    const skipGuessBtn = document.getElementById("skipGuessBtn");
    const revealTileBtn = document.getElementById("revealTileBtn");
    const nextRoundBtn = document.getElementById("nextRoundBtn");

    const boardContainer = document.getElementById("boardContainer");
    const imageLayer = document.getElementById("imageLayer");
    const tilesLayer = document.getElementById("tilesLayer");
    const overlayMessage = document.getElementById("overlayMessage");

    const reaperMascot = document.getElementById("reaperMascotWrapper");

    // Collapsible setup
    const setupToggle = document.getElementById("setupToggle");
    const setupToggleIcon = document.getElementById("setupToggleIcon");
    const setupContent = document.getElementById("setupContent");

    // ----- Helpers -----
    function setSetupStatus(message, type = "") {
      setupStatus.textContent = message || "";
      setupStatus.classList.remove("ok", "error");
      if (type) setupStatus.classList.add(type);
    }

    function setGuessStatus(message, type = "") {
      guessStatus.textContent = message || "";
      guessStatus.classList.remove("ok", "error");
      if (type) guessStatus.classList.add(type);
    }

    function normalizeAnswer(str) {
      return (str || "")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function updatePlayerNames() {
      score1NameEl.textContent = "Xylie";
      score2NameEl.textContent = "Josh";
      currentTurnLabel.textContent =
        currentPlayerIndex === 0 ? "Xylie" : "Josh";
    }

    function updateScores() {
      score1El.textContent = scores[0];
      score2El.textContent = scores[1];
    }

    function highlightCurrentTurn() {
      score1Badge.classList.toggle("current-turn", currentPlayerIndex === 0);
      score2Badge.classList.toggle("current-turn", currentPlayerIndex === 1);
      updatePlayerNames();
    }

    function switchTurn() {
      currentPlayerIndex = currentPlayerIndex === 0 ? 1 : 0;
      highlightCurrentTurn();
    }

    function showOverlayMessage(text) {
      overlayMessage.textContent = text;
      overlayMessage.classList.add("visible");
    }

    function hideOverlayMessage() {
      overlayMessage.textContent = "";
      overlayMessage.classList.remove("visible");
    }

    function disableGameControls(disabled) {
      revealAllBtn.disabled = disabled;
      submitGuessBtn.disabled = disabled;
      skipGuessBtn.disabled = disabled;
      guessInput.disabled = disabled;
      if (disabled) {
        revealTileBtn.disabled = true;
      } else {
        revealTileBtn.disabled = !canReveal;
      }
    }

    // Reaper animation helper with glow reset
    function triggerReaperAnimation(type) {
      if (!reaperMascot) return;
      const img = reaperMascot.querySelector("img");
      reaperMascot.classList.remove("wrong", "correct");
      if (img) {
        img.style.filter = "drop-shadow(0 0 10px rgba(0,0,0,0.9))";
      }

      void reaperMascot.offsetWidth; // restart animation

      if (type === "wrong") {
        reaperMascot.classList.add("wrong");
        setTimeout(() => {
          reaperMascot.classList.remove("wrong");
          if (img) img.style.filter = "drop-shadow(0 0 10px rgba(0,0,0,0.9))";
        }, 650);
      } else if (type === "correct") {
        reaperMascot.classList.add("correct");
        setTimeout(() => {
          reaperMascot.classList.remove("correct");
          if (img) img.style.filter = "drop-shadow(0 0 10px rgba(0,0,0,0.9))";
        }, 900);
      }
    }

    // Collapsible behaviour
    function setSetupCollapsed(collapsed) {
      if (collapsed) {
        setupContent.classList.add("collapsed");
        setupToggleIcon.textContent = "▼";
      } else {
        setupContent.classList.remove("collapsed");
        setupToggleIcon.textContent = "▲";
      }
    }

    setupToggle.addEventListener("click", () => {
      const collapsed = setupContent.classList.contains("collapsed");
      setSetupCollapsed(!collapsed);
    });

    // ----- Load puzzles.json -----
    async function loadPuzzles() {
      try {
        const res = await fetch("data/puzzles.json", { cache: "no-store" });
        if (!res.ok) {
          throw new Error("HTTP " + res.status);
        }
        const data = await res.json();
        if (!Array.isArray(data) || data.length === 0) {
          puzzleLoadInfo.textContent = "No puzzles found in data/puzzles.json.";
          setSetupStatus("No puzzles loaded. Check data/puzzles.json.", "error");
          return;
        }
        puzzles = data;
        puzzleLoadInfo.textContent = `Puzzles loaded: ${puzzles.length}. Ready to play.`;
        setSetupStatus("Puzzles loaded. Set rows/columns and click Start / Reset Round.", "ok");
      } catch (err) {
        console.error("Error loading puzzles:", err);
        puzzleLoadInfo.textContent = "Failed to load puzzles.";
        setSetupStatus("Failed to load data/puzzles.json. Make sure it exists on the server.", "error");
      }
    }

    // ----- Round Setup -----
    function pickRandomPuzzle() {
      if (!puzzles || puzzles.length === 0) return null;
    
      // If all puzzles have been used, reset the cycle
      if (usedPuzzleIndices.length === puzzles.length) {
        usedPuzzleIndices = [];
      }
    
      // Pick an unused one
      let index;
      do {
        index = Math.floor(Math.random() * puzzles.length);
      } while (usedPuzzleIndices.includes(index));
    
      usedPuzzleIndices.push(index);
      return puzzles[index];
    }


    function setupRound() {
      setGuessStatus("");
      hideOverlayMessage();

      if (!puzzles || puzzles.length === 0) {
        setSetupStatus("No puzzles loaded yet. Check data/puzzles.json.", "error");
        return;
      }

      const rows = parseInt(rowsInput.value, 10) || 0;
      const cols = parseInt(colsInput.value, 10) || 0;

      if (rows <= 0 || cols <= 0) {
        setSetupStatus("Rows and columns must be at least 1.", "error");
        return;
      }

      const puzzle = pickRandomPuzzle();
      if (!puzzle || !puzzle.image || !Array.isArray(puzzle.answers) || puzzle.answers.length === 0) {
        setSetupStatus("Random puzzle is invalid. Check data/puzzles.json.", "error");
        return;
      }

      // who starts this round?
      currentPlayerIndex = nextStartingPlayerIndex;
      highlightCurrentTurn();

      currentPuzzle = puzzle;
      currentPuzzleAnswersNormalized = puzzle.answers.map(normalizeAnswer);

      imageLayer.style.backgroundImage = `url('${puzzle.image}')`;

      tilesLayer.innerHTML = "";
      tiles = [];
      unrevealedTileIndices = [];
      totalTiles = rows * cols;
      revealedTilesCount = 0;

      tilesLayer.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
      tilesLayer.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

      for (let i = 0; i < totalTiles; i++) {
        const div = document.createElement("div");
        div.classList.add("tile");
        tilesLayer.appendChild(div);
        tiles.push(div);
        unrevealedTileIndices.push(i);
      }

      gameActive = true;
      canReveal = true;
      nextRoundBtn.disabled = true;
      disableGameControls(false);
      revealAllBtn.disabled = false;
      guessInput.value = "";
      setSetupStatus(`Round started with ${rows} × ${cols} grid (${totalTiles} tiles).`, "ok");
      setGuessStatus("Reveal a tile and let the current player guess or skip.", "ok");
      hideOverlayMessage();
      setSetupCollapsed(true); // auto-collapse when round starts
    }

    startRoundBtn.addEventListener("click", setupRound);

    // ----- Tile revealing helpers -----
    function revealTileByIndex(tileIndex) {
      if (!Number.isInteger(tileIndex) || tileIndex < 0 || tileIndex >= tiles.length) return;
      const tile = tiles[tileIndex];
      if (!tile || tile.classList.contains("revealed")) return;

      tile.classList.add("revealed");

      const idxInUnrevealed = unrevealedTileIndices.indexOf(tileIndex);
      if (idxInUnrevealed !== -1) {
        unrevealedTileIndices.splice(idxInUnrevealed, 1);
      }

      revealedTilesCount++;
    }

    // ----- Reveal Tiles with suspense animation -----
    function revealRandomTileWithAnimation() {
      if (!gameActive) {
        setGuessStatus("Start a round first.", "error");
        return;
      }
      if (unrevealedTileIndices.length === 0) {
        setGuessStatus("All tiles are already revealed.", "error");
        return;
      }
      if (revealAnimationRunning || !canReveal) {
        return; // ignore if already running or reveal not allowed
      }

      setSetupCollapsed(true); // collapse whenever Reveal pressed

      revealAnimationRunning = true;
      revealTileBtn.disabled = true;

      const highlightDurationMs = 3000;
      const stepMs = 150;
      const steps = Math.floor(highlightDurationMs / stepMs);
      let currentStep = 0;
      let lastHighlightedIndex = null;

      const intervalId = setInterval(() => {
        if (!gameActive || unrevealedTileIndices.length === 0) {
          clearInterval(intervalId);
          if (lastHighlightedIndex !== null && tiles[lastHighlightedIndex]) {
            tiles[lastHighlightedIndex].classList.remove("highlight");
          }
          revealAnimationRunning = false;
          return;
        }

        const randomPos = Math.floor(Math.random() * unrevealedTileIndices.length);
        const tileIndex = unrevealedTileIndices[randomPos];

        if (lastHighlightedIndex !== null && tiles[lastHighlightedIndex]) {
          tiles[lastHighlightedIndex].classList.remove("highlight");
        }
        if (tiles[tileIndex]) {
          tiles[tileIndex].classList.add("highlight");
        }
        lastHighlightedIndex = tileIndex;
        currentStep++;

        if (currentStep >= steps) {
          clearInterval(intervalId);

          if (lastHighlightedIndex !== null && tiles[lastHighlightedIndex]) {
            tiles[lastHighlightedIndex].classList.remove("highlight");
          }

          const finalIndex = tileIndex;
          revealTileByIndex(finalIndex);

          revealAnimationRunning = false;
          canReveal = false;
          revealTileBtn.disabled = true;

          setGuessStatus("Tile revealed. Current player may guess or skip.", "");
        }
      }, stepMs);
    }

    revealTileBtn.addEventListener("click", revealRandomTileWithAnimation);

    // ----- Reveal All -----
    function revealAllTiles() {
      tiles.forEach((tile) => {
        if (tile && !tile.classList.contains("revealed")) {
          tile.classList.add("revealed");
        }
      });
      unrevealedTileIndices = [];
      revealedTilesCount = totalTiles;
    }

    revealAllBtn.addEventListener("click", () => {
      if (!currentPuzzle) {
        revealAllTiles();
        return;
      }
      if (!gameActive) {
        revealAllTiles();
        return;
      }
      revealAllTiles();
      gameActive = false;
      disableGameControls(true);
      showOverlayMessage("Round over – no correct guess!");
      setGuessStatus("Round ended. Click Start / Reset Round for a new puzzle.", "error");
      // No winner in this case -> Next stays disabled, start via Setup if needed
    });

    // ----- Guess Handling -----
    function handleGuess() {
      if (!gameActive) {
        setGuessStatus("Start a round first.", "error");
        return;
      }
      if (!currentPuzzle) {
        setGuessStatus("No puzzle selected. Start a round.", "error");
        return;
      }

      const guess = guessInput.value.trim();
      if (!guess) {
        setGuessStatus("Enter a guess first or use Skip.", "error");
        return;
      }

      setSetupCollapsed(true); // collapse whenever Guess pressed

      const normalizedGuess = normalizeAnswer(guess);
      const isCorrect = currentPuzzleAnswersNormalized.some((ans) => ans === normalizedGuess);

      if (isCorrect) {
        const tilesRemaining = totalTiles - revealedTilesCount;
        const pointsAwarded = tilesRemaining + 1;
        scores[currentPlayerIndex] += pointsAwarded;
        updateScores();

        const playerName = currentPlayerIndex === 0 ? "Xylie" : "Josh";

        setGuessStatus(
          `${playerName} is correct! +${pointsAwarded} points (tiles remaining: ${tilesRemaining}).`,
          "ok"
        );
        revealAllTiles();
        gameActive = false;
        disableGameControls(true);
        showOverlayMessage(`${playerName} got it!\n+${pointsAwarded} points`);

        triggerReaperAnimation("correct");

        // next round starts with the opposite player
        nextStartingPlayerIndex = currentPlayerIndex === 0 ? 1 : 0;
        nextRoundBtn.disabled = false;
      } else {
        setGuessStatus("Incorrect guess. Turn passes to the other player.", "error");
        guessInput.value = "";
        switchTurn();

        // After an incorrect guess, allow Reveal again (if tiles remain)
        if (gameActive && unrevealedTileIndices.length > 0) {
          canReveal = true;
          revealTileBtn.disabled = false;
        }

        triggerReaperAnimation("wrong");
      }
    }

    submitGuessBtn.addEventListener("click", handleGuess);

    guessInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        handleGuess();
      }
    });

    skipGuessBtn.addEventListener("click", () => {
      if (!gameActive) {
        setGuessStatus("Start a round first.", "error");
        return;
      }

      setSetupCollapsed(true); // collapse whenever Skip pressed

      setGuessStatus("Turn skipped. Passing to the other player.", "");
      guessInput.value = "";
      switchTurn();

      if (gameActive && unrevealedTileIndices.length > 0) {
        canReveal = true;
        revealTileBtn.disabled = false;
      }

      triggerReaperAnimation("wrong");
    });

    // ----- Next Round from main panel -----
    nextRoundBtn.addEventListener("click", () => {
      if (!puzzles || puzzles.length === 0) return;
      setupRound();
    });

    // ----- Scores reset -----
    resetScoresBtn.addEventListener("click", () => {
      scores = [0, 0];
      updateScores();
      setSetupStatus("Scores reset.", "ok");
    });

    // ----- Init -----
    updateScores();
    highlightCurrentTurn();
    disableGameControls(true);
    setSetupCollapsed(false); // open on first load
    setSetupStatus("Loading puzzles…", "");
    loadPuzzles();
  </script>
</body>
</html>


